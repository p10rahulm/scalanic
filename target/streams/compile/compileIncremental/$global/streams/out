[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial source changes: [0m
[0m[[0m[0mdebug[0m] [0m[0m	removed:Set(E:\Learn\Scala\src\main\scala\scriptFile.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	added: Set(E:\Learn\Scala\src\main\scala\streams_bloxorz\Bloxorz.scala, E:\Learn\Scala\src\main\scala\streams_bloxorz\GameDef.scala, E:\Learn\Scala\src\main\scala\TweetLength.scala, E:\Learn\Scala\src\main\scala\Calculator.scala, E:\Learn\Scala\src\main\scala\streams_bloxorz\BloxorzSuite.scala, E:\Learn\Scala\src\main\scala\streams_bloxorz\StringParserTerrain.scala, E:\Learn\Scala\src\main\scala\Signal.scala, E:\Learn\Scala\src\main\scala\streams_bloxorz\InfiniteTerrain.scala, E:\Learn\Scala\src\main\scala\Heap.scala, E:\Learn\Scala\src\main\scala\streams_bloxorz\Solver.scala, E:\Learn\Scala\src\main\scala\Polynomial.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	modified: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated products: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mExternal API changes: API Changes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mModified binary dependencies: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial directly invalidated classes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mSources indirectly invalidated by:[0m
[0m[[0m[0mdebug[0m] [0m[0m	product: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	binary dep: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	external source: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated classes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated sources:Set(E:\Learn\Scala\src\main\scala\streams_bloxorz\Bloxorz.scala, E:\Learn\Scala\src\main\scala\streams_bloxorz\GameDef.scala, E:\Learn\Scala\src\main\scala\TweetLength.scala, E:\Learn\Scala\src\main\scala\Calculator.scala, E:\Learn\Scala\src\main\scala\streams_bloxorz\BloxorzSuite.scala, E:\Learn\Scala\src\main\scala\streams_bloxorz\StringParserTerrain.scala, E:\Learn\Scala\src\main\scala\Signal.scala, E:\Learn\Scala\src\main\scala\streams_bloxorz\InfiniteTerrain.scala, E:\Learn\Scala\src\main\scala\Heap.scala, E:\Learn\Scala\src\main\scala\streams_bloxorz\Solver.scala, E:\Learn\Scala\src\main\scala\Polynomial.scala)[0m
[0m[[0m[0minfo[0m] [0m[0mCompiling 11 Scala sources to E:\Learn\Scala\target\scala-2.12\classes ...[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.12:1.2.5:compile for Scala 2.12.8[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.12:1.2.5:compile for Scala 2.12.8[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] Running cached compiler 370a6abd for Scala compiler version 2.12.8[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] The Scala compiler is invoked with:[0m
[0m[[0m[0mdebug[0m] [0m[0m	-bootclasspath[0m
[0m[[0m[0mdebug[0m] [0m[0m	C:\Users\rmaddy\.ivy2\cache\org.scala-lang\scala-library\jars\scala-library-2.12.8.jar[0m
[0m[[0m[0mdebug[0m] [0m[0m	-classpath[0m
[0m[[0m[0mdebug[0m] [0m[0m	E:\Learn\Scala\target\scala-2.12\classes;C:\Users\rmaddy\.ivy2\cache\org.scala-lang.modules\scala-parser-combinators_2.12\bundles\scala-parser-combinators_2.12-1.0.4.jar[0m
[0m[[0m[0mdebug[0m] [0m[0mScala compilation took 3.210495341 s[0m
[0m[[0m[0minfo[0m] [0m[0mDone compiling.[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.GameDef.Down...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.GameDef.Down)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.GameDef.Down)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(ne,[Default]), UsedName(Down,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.Level1: Set(UsedName(Down,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.GameDef.Down,ModifiedNames(changes = UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 3 classes due to The streams_bloxorz.GameDef.Down has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.GameDef.Down)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.BloxorzSuite.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.Solver...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.Solver)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.BloxorzSuite.SolutionChecker by streams_bloxorz.Solver[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.BloxorzSuite.Level1 by streams_bloxorz.BloxorzSuite.SolutionChecker[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.Level by streams_bloxorz.Solver[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.Level0 by streams_bloxorz.Bloxorz.Level[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.Level1 by streams_bloxorz.Bloxorz.Level[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.InfiniteLevel by streams_bloxorz.Solver[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.Solver, streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.Bloxorz.InfiniteLevel, streams_bloxorz.Bloxorz.Level0, streams_bloxorz.Bloxorz.Level, streams_bloxorz.BloxorzSuite.Level1, streams_bloxorz.Bloxorz.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidate by local inheritance: streams_bloxorz.BloxorzSuite.Level1 -> Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(Move,[Default, PatMatTarget]), UsedName(ne,[Default]), UsedName(Right,[Default]), UsedName(Block,[Default]), UsedName(Down,[Default]), UsedName(Up,[Default]), UsedName(startBlock,[Default]), UsedName(Left,[Default]), UsedName(Solver,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite: Set(UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(Move,[Default]), UsedName(startPos,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName(Pos,[Default]), UsedName(terrain,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Bloxorz.InfiniteLevel: Set(UsedName(startPos,[Default]), UsedName(goal,[Default]), UsedName(Pos,[Default]), UsedName(Solver,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Bloxorz: Set(UsedName(solution,[Default]), UsedName(Move,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Bloxorz.Level: Set(UsedName(Solver,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.Solver,ModifiedNames(changes = UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(Solver,[Default]), UsedName(equals,[Default]))) invalidates 9 classes due to The streams_bloxorz.Solver has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(Solver,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.Solver, streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.Bloxorz.InfiniteLevel, streams_bloxorz.Bloxorz.Level0, streams_bloxorz.Bloxorz.Level, streams_bloxorz.BloxorzSuite.Level1, streams_bloxorz.Bloxorz.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by local inheritance: Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.BloxorzSuite, streams_bloxorz.Bloxorz.InfiniteLevel, streams_bloxorz.Bloxorz, streams_bloxorz.Bloxorz.Level)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from NoSignal...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(NoSignal)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(NoSignal)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(NoSignal,ModifiedNames(changes = UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(computeValue,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(NoSignal,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(update,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The NoSignal has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(computeValue,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(NoSignal,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(update,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(NoSignal)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Minus...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Minus)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Minus)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Minus,ModifiedNames(changes = UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(b,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(Minus,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(a,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Minus;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The Minus has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(b,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(Minus,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(a,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Minus;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Minus)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Literal...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Literal)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Literal)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Literal,ModifiedNames(changes = UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(Literal;init;,[Default]), UsedName(v,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(Literal,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The Literal has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(Literal;init;,[Default]), UsedName(v,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(Literal,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Literal)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.BloxorzSuite...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.BloxorzSuite,ModifiedNames(changes = UsedName(==,[Default]), UsedName(b,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(c,[Default]), UsedName(getClass,[Default]), UsedName(Level1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(streams_bloxorz;BloxorzSuite;init;,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(a,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(SolutionChecker,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(d,[Default]), UsedName(##,[Default]), UsedName(BloxorzSuite,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The streams_bloxorz.BloxorzSuite has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(b,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(c,[Default]), UsedName(getClass,[Default]), UsedName(Level1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(streams_bloxorz;BloxorzSuite;init;,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(a,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(SolutionChecker,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(d,[Default]), UsedName(##,[Default]), UsedName(BloxorzSuite,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.BloxorzSuite.SolutionChecker...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.BloxorzSuite.SolutionChecker)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.BloxorzSuite.Level1 by streams_bloxorz.BloxorzSuite.SolutionChecker[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.BloxorzSuite.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidate by local inheritance: streams_bloxorz.BloxorzSuite.Level1 -> Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.BloxorzSuite.SolutionChecker,ModifiedNames(changes = UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(level,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(SolutionChecker,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(terrainFunction,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(findChar,[Default]), UsedName(solve,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 3 classes due to The streams_bloxorz.BloxorzSuite.SolutionChecker has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(level,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(SolutionChecker,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(terrainFunction,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(findChar,[Default]), UsedName(solve,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.BloxorzSuite.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by local inheritance: Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Times...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Times)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Times)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Times,ModifiedNames(changes = UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(b,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(Times;init;,[Default]), UsedName(a,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Times,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The Times has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(b,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(Times;init;,[Default]), UsedName(a,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Times,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Times)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.GameDef.Block...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.GameDef.Block)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.GameDef.Block)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Solver: Set(UsedName(b1,[Default]), UsedName(==,[Default]), UsedName(isStanding,[Default]), UsedName(b2,[Default]), UsedName(neighbors,[Default]), UsedName(legalNeighbors,[Default]), UsedName(apply,[Default]), UsedName(Block,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(down,[Default]), UsedName(right,[Default]), UsedName(ne,[Default]), UsedName(up,[Default]), UsedName(isLegal,[Default]), UsedName(apply,[Default]), UsedName(Block,[Default]), UsedName(left,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite: Set(UsedName(==,[Default]), UsedName(apply,[Default]), UsedName(Block,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.GameDef.Block,ModifiedNames(changes = UsedName(copy$default$1,[Default]), UsedName(deltaCol,[Default]), UsedName(b1,[Default]), UsedName(==,[Default]), UsedName(isStanding,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(deltaRow,[Default]), UsedName(down,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(unapply,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(right,[Default]), UsedName(b2,[Default]), UsedName(neighbors,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(up,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(legalNeighbors,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(isLegal,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName(apply,[Default]), UsedName(streams_bloxorz;GameDef;Block;init;,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(left,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(curried,[Default]), UsedName(equals,[Default]), UsedName(tupled,[Default]))) invalidates 4 classes due to The streams_bloxorz.GameDef.Block has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(copy$default$1,[Default]), UsedName(deltaCol,[Default]), UsedName(b1,[Default]), UsedName(==,[Default]), UsedName(isStanding,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(deltaRow,[Default]), UsedName(down,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(unapply,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(right,[Default]), UsedName(b2,[Default]), UsedName(neighbors,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(up,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(legalNeighbors,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(isLegal,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName(apply,[Default]), UsedName(streams_bloxorz;GameDef;Block;init;,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(left,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(curried,[Default]), UsedName(equals,[Default]), UsedName(tupled,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.GameDef.Block)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(streams_bloxorz.Solver, streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Signal...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Signal)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding NoSignal by Signal[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding Var by Signal[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Signal, Var, NoSignal)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of TweetLength: Set(UsedName(apply,[Default]), UsedName(Signal,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of Calculator: Set(UsedName(asInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(Signal,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of Polynomial: Set(UsedName(==,[Default]), UsedName(apply,[Default]), UsedName(Signal,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Signal,ModifiedNames(changes = UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(computeValue,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(apply,[Default]), UsedName(Signal,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Signal;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(caller,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(update,[Default]), UsedName(equals,[Default]))) invalidates 6 classes due to The Signal has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(computeValue,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(apply,[Default]), UsedName(Signal,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Signal;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(caller,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(update,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Signal, Var, NoSignal)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(TweetLength, Calculator, Polynomial)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Expr...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Expr)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding Divide by Expr[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding Literal by Expr[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding Plus by Expr[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding Minus by Expr[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding Times by Expr[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding Ref by Expr[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Expr, Divide, Literal, Plus, Minus, Times, Ref)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Expr,ModifiedNames(changes = UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Expr;init;,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(Expr,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 7 classes due to The Expr has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Expr;init;,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(Expr,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Expr, Divide, Literal, Plus, Minus, Times, Ref)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.GameDef.Right...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.GameDef.Right)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.GameDef.Right)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(ne,[Default]), UsedName(Right,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.Level1: Set(UsedName(Right,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.GameDef.Right,ModifiedNames(changes = UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 3 classes due to The streams_bloxorz.GameDef.Right has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.GameDef.Right)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.BloxorzSuite.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from TweetLength...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(TweetLength)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(TweetLength)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(TweetLength,ModifiedNames(changes = UsedName(TweetLength,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(colorForRemainingCharsCount,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(MaxTweetLength,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(tweetRemainingCharsCount,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The TweetLength has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(TweetLength,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(colorForRemainingCharsCount,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(MaxTweetLength,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(tweetRemainingCharsCount,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(TweetLength)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.BloxorzSuite.Level1...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.BloxorzSuite.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.BloxorzSuite.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidate by local inheritance: streams_bloxorz.BloxorzSuite.Level1 -> Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.BloxorzSuite.Level1,ModifiedNames(changes = UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(Level1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(level,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(terrainFunction,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(findChar,[Default]), UsedName(solve,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(optsolution,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 2 classes due to The streams_bloxorz.BloxorzSuite.Level1 has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(Level1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(level,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(terrainFunction,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(findChar,[Default]), UsedName(solve,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(optsolution,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.BloxorzSuite.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by local inheritance: Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.GameDef.Move...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.GameDef.Move)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.GameDef.Left by streams_bloxorz.GameDef.Move[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.GameDef.Down by streams_bloxorz.GameDef.Move[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.GameDef.Right by streams_bloxorz.GameDef.Move[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.GameDef.Up by streams_bloxorz.GameDef.Move[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.GameDef.Down, streams_bloxorz.GameDef.Move, streams_bloxorz.GameDef.Right, streams_bloxorz.GameDef.Left, streams_bloxorz.GameDef.Up)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(Move,[Default, PatMatTarget]), UsedName(ne,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mNone of the modified names appears in source file of streams_bloxorz.BloxorzSuite.Level1. This dependency is not being considered for invalidation.[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Solver: Set(UsedName(==,[Default]), UsedName(Move,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(Move,[Default, PatMatTarget]), UsedName(ne,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite: Set(UsedName(==,[Default]), UsedName(Move,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Bloxorz: Set(UsedName(Move,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mNone of the modified names appears in source file of streams_bloxorz.BloxorzSuite.Level1. This dependency is not being considered for invalidation.[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(Move,[Default, PatMatTarget]), UsedName(ne,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mNone of the modified names appears in source file of streams_bloxorz.BloxorzSuite.Level1. This dependency is not being considered for invalidation.[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(Move,[Default, PatMatTarget]), UsedName(ne,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(Move,[Default, PatMatTarget]), UsedName(ne,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.GameDef.Move,ModifiedNames(changes = UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(streams_bloxorz;GameDef;Move;init;,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 9 classes due to The streams_bloxorz.GameDef.Move has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(streams_bloxorz;GameDef;Move;init;,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.GameDef.Down, streams_bloxorz.GameDef.Move, streams_bloxorz.GameDef.Right, streams_bloxorz.GameDef.Left, streams_bloxorz.GameDef.Up)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(streams_bloxorz.Solver, streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.BloxorzSuite, streams_bloxorz.Bloxorz)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.GameDef...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.GameDef)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.InfiniteTerrain by streams_bloxorz.GameDef[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.InfiniteLevel by streams_bloxorz.InfiniteTerrain[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Solver by streams_bloxorz.GameDef[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.BloxorzSuite.SolutionChecker by streams_bloxorz.Solver[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.BloxorzSuite.Level1 by streams_bloxorz.BloxorzSuite.SolutionChecker[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.Level by streams_bloxorz.Solver[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.Level0 by streams_bloxorz.Bloxorz.Level[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.Level1 by streams_bloxorz.Bloxorz.Level[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.StringParserTerrain by streams_bloxorz.GameDef[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.StringParserTerrain, streams_bloxorz.Solver, streams_bloxorz.InfiniteTerrain, streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.Bloxorz.InfiniteLevel, streams_bloxorz.GameDef, streams_bloxorz.Bloxorz.Level0, streams_bloxorz.Bloxorz.Level, streams_bloxorz.BloxorzSuite.Level1, streams_bloxorz.Bloxorz.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidate by local inheritance: streams_bloxorz.BloxorzSuite.Level1 -> Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite: Set(UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(Move,[Default]), UsedName(startPos,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName(Pos,[Default]), UsedName(terrain,[Default]), UsedName(GameDef,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(Move,[Default, PatMatTarget]), UsedName(ne,[Default]), UsedName(Right,[Default]), UsedName(Block,[Default]), UsedName(Down,[Default]), UsedName(Up,[Default]), UsedName(GameDef,[Default]), UsedName(startBlock,[Default]), UsedName(Left,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mNone of the modified names appears in source file of streams_bloxorz.Bloxorz.Level. This dependency is not being considered for invalidation.[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(Move,[Default, PatMatTarget]), UsedName(ne,[Default]), UsedName(Right,[Default]), UsedName(Block,[Default]), UsedName(Down,[Default]), UsedName(Up,[Default]), UsedName(GameDef,[Default]), UsedName(startBlock,[Default]), UsedName(Left,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite: Set(UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(Move,[Default]), UsedName(startPos,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName(Pos,[Default]), UsedName(terrain,[Default]), UsedName(GameDef,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Bloxorz.InfiniteLevel: Set(UsedName(startPos,[Default]), UsedName(goal,[Default]), UsedName(Pos,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Bloxorz: Set(UsedName(Move,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mNone of the modified names appears in source file of streams_bloxorz.Bloxorz.Level. This dependency is not being considered for invalidation.[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Bloxorz.InfiniteLevel: Set(UsedName(startPos,[Default]), UsedName(goal,[Default]), UsedName(Pos,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.StringParserTerrain: Set(UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(!=,[Default]), UsedName(Pos,[Default]), UsedName(GameDef,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Solver: Set(UsedName(==,[Default]), UsedName(Move,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName(Pos,[Default]), UsedName(GameDef,[Default]), UsedName(startBlock,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.InfiniteTerrain: Set(UsedName(Terrain,[Default]), UsedName(Pos,[Default]), UsedName(GameDef,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(Move,[Default, PatMatTarget]), UsedName(ne,[Default]), UsedName(Right,[Default]), UsedName(Block,[Default]), UsedName(Down,[Default]), UsedName(Up,[Default]), UsedName(GameDef,[Default]), UsedName(startBlock,[Default]), UsedName(Left,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite: Set(UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(Move,[Default]), UsedName(startPos,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName(Pos,[Default]), UsedName(terrain,[Default]), UsedName(GameDef,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.GameDef,ModifiedNames(changes = UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Pos,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(GameDef,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 12 classes due to The streams_bloxorz.GameDef has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Pos,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(GameDef,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.StringParserTerrain, streams_bloxorz.Solver, streams_bloxorz.InfiniteTerrain, streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.Bloxorz.InfiniteLevel, streams_bloxorz.GameDef, streams_bloxorz.Bloxorz.Level0, streams_bloxorz.Bloxorz.Level, streams_bloxorz.BloxorzSuite.Level1, streams_bloxorz.Bloxorz.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by local inheritance: Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(streams_bloxorz.StringParserTerrain, streams_bloxorz.Solver, streams_bloxorz.InfiniteTerrain, streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.BloxorzSuite, streams_bloxorz.Bloxorz.InfiniteLevel, streams_bloxorz.Bloxorz)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from BinomialHeap.Node...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(BinomialHeap.Node)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(BinomialHeap.Node)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(BinomialHeap.Node,ModifiedNames(changes = UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(c,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(unapply,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(x,[Default]), UsedName(BinomialHeap;Node;init;,[Default]), UsedName(toString,[Default]), UsedName(copy$default$3,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(Node,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(curried,[Default]), UsedName(equals,[Default]), UsedName(r,[Default]), UsedName(tupled,[Default]))) invalidates 1 classes due to The BinomialHeap.Node has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(c,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(unapply,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(x,[Default]), UsedName(BinomialHeap;Node;init;,[Default]), UsedName(toString,[Default]), UsedName(copy$default$3,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(Node,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(curried,[Default]), UsedName(equals,[Default]), UsedName(r,[Default]), UsedName(tupled,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(BinomialHeap.Node)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.Bloxorz...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.Bloxorz)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.Bloxorz)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.Bloxorz,ModifiedNames(changes = UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(Level1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(delayedInit,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(args,[Default]), UsedName(main,[Default]), UsedName(InfiniteLevel,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Bloxorz,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(Level0,[Default]), UsedName(executionStart,[Default]), UsedName(hashCode,[Default]), UsedName(Level,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The streams_bloxorz.Bloxorz has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(Level1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(delayedInit,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(args,[Default]), UsedName(main,[Default]), UsedName(InfiniteLevel,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Bloxorz,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(Level0,[Default]), UsedName(executionStart,[Default]), UsedName(hashCode,[Default]), UsedName(Level,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.Bloxorz)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.StringParserTerrain...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.StringParserTerrain)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.BloxorzSuite.SolutionChecker by streams_bloxorz.StringParserTerrain[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.BloxorzSuite.Level1 by streams_bloxorz.BloxorzSuite.SolutionChecker[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.Level by streams_bloxorz.StringParserTerrain[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.Level0 by streams_bloxorz.Bloxorz.Level[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.Level1 by streams_bloxorz.Bloxorz.Level[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.StringParserTerrain, streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.Bloxorz.Level0, streams_bloxorz.Bloxorz.Level, streams_bloxorz.BloxorzSuite.Level1, streams_bloxorz.Bloxorz.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidate by local inheritance: streams_bloxorz.BloxorzSuite.Level1 -> Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite: Set(UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(Move,[Default]), UsedName(startPos,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName(Pos,[Default]), UsedName(terrain,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(Move,[Default, PatMatTarget]), UsedName(ne,[Default]), UsedName(Right,[Default]), UsedName(Block,[Default]), UsedName(Down,[Default]), UsedName(Up,[Default]), UsedName(startBlock,[Default]), UsedName(Left,[Default]), UsedName(StringParserTerrain,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Bloxorz.Level: Set(UsedName(StringParserTerrain,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.StringParserTerrain,ModifiedNames(changes = UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(level,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(terrainFunction,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Pos,[Default]), UsedName(findChar,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(StringParserTerrain,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 7 classes due to The streams_bloxorz.StringParserTerrain has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(level,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(terrainFunction,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Pos,[Default]), UsedName(findChar,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(StringParserTerrain,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.StringParserTerrain, streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.Bloxorz.Level0, streams_bloxorz.Bloxorz.Level, streams_bloxorz.BloxorzSuite.Level1, streams_bloxorz.Bloxorz.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by local inheritance: Set(streams_bloxorz.BloxorzSuite)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(streams_bloxorz.BloxorzSuite.SolutionChecker, streams_bloxorz.BloxorzSuite, streams_bloxorz.Bloxorz.Level)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Divide...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Divide)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Divide)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Divide,ModifiedNames(changes = UsedName(copy$default$1,[Default]), UsedName(Divide;init;,[Default]), UsedName(==,[Default]), UsedName(b,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(Divide,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(a,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The Divide has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(copy$default$1,[Default]), UsedName(Divide;init;,[Default]), UsedName(==,[Default]), UsedName(b,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(Divide,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(a,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Divide)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.GameDef.Pos...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.GameDef.Pos)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.GameDef.Pos)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.StringParserTerrain: Set(UsedName(==,[Default]), UsedName(col,[Default]), UsedName(!=,[Default]), UsedName(apply,[Default]), UsedName(Pos,[Default]), UsedName(row,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Solver: Set(UsedName(==,[Default]), UsedName(apply,[Default]), UsedName(Pos,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.InfiniteTerrain: Set(UsedName(Pos,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite: Set(UsedName(==,[Default]), UsedName(apply,[Default]), UsedName(Pos,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Bloxorz.InfiniteLevel: Set(UsedName(apply,[Default]), UsedName(Pos,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.GameDef.Pos,ModifiedNames(changes = UsedName(copy$default$1,[Default]), UsedName(deltaCol,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(deltaRow,[Default]), UsedName(getClass,[Default]), UsedName(col,[Default]), UsedName(asInstanceOf,[Default]), UsedName(unapply,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(streams_bloxorz;GameDef;Pos;init;,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Pos,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(row,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(curried,[Default]), UsedName(equals,[Default]), UsedName(tupled,[Default]))) invalidates 6 classes due to The streams_bloxorz.GameDef.Pos has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(copy$default$1,[Default]), UsedName(deltaCol,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(deltaRow,[Default]), UsedName(getClass,[Default]), UsedName(col,[Default]), UsedName(asInstanceOf,[Default]), UsedName(unapply,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(streams_bloxorz;GameDef;Pos;init;,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Pos,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(row,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(curried,[Default]), UsedName(equals,[Default]), UsedName(tupled,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.GameDef.Pos)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(streams_bloxorz.StringParserTerrain, streams_bloxorz.Solver, streams_bloxorz.InfiniteTerrain, streams_bloxorz.BloxorzSuite, streams_bloxorz.Bloxorz.InfiniteLevel)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from IntHeap...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(IntHeap)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(IntHeap)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(IntHeap,ModifiedNames(changes = UsedName(insert,[Default]), UsedName(ord,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(findMin,[Default]), UsedName(!=,[Default]), UsedName(A,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(meld,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isEmpty,[Default]), UsedName(H,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(empty,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(deleteMin,[Default]), UsedName(equals,[Default]), UsedName(IntHeap,[Default]))) invalidates 1 classes due to The IntHeap has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(insert,[Default]), UsedName(ord,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(findMin,[Default]), UsedName(!=,[Default]), UsedName(A,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(meld,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isEmpty,[Default]), UsedName(H,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(empty,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(deleteMin,[Default]), UsedName(equals,[Default]), UsedName(IntHeap,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(IntHeap)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Calculator...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Calculator)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Calculator)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Calculator,ModifiedNames(changes = UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(computeValues,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(Calculator,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(eval,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The Calculator has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(computeValues,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(Calculator,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(eval,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Calculator)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Plus...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Plus)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Plus)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Plus,ModifiedNames(changes = UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(b,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(Plus,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(Plus;init;,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(a,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The Plus has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(b,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(Plus,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(Plus;init;,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(a,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Plus)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.Bloxorz.Level...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.Bloxorz.Level)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.Level0 by streams_bloxorz.Bloxorz.Level[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.Level1 by streams_bloxorz.Bloxorz.Level[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.Bloxorz.Level0, streams_bloxorz.Bloxorz.Level1, streams_bloxorz.Bloxorz.Level)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.Bloxorz.Level,ModifiedNames(changes = UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(streams_bloxorz;Bloxorz;Level;init;,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(level,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(terrainFunction,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(findChar,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(Level,[Default]), UsedName(equals,[Default]))) invalidates 3 classes due to The streams_bloxorz.Bloxorz.Level has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(streams_bloxorz;Bloxorz;Level;init;,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(level,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(terrainFunction,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(findChar,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(Level,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.Bloxorz.Level0, streams_bloxorz.Bloxorz.Level1, streams_bloxorz.Bloxorz.Level)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.Bloxorz.InfiniteLevel...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.Bloxorz.InfiniteLevel)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.Bloxorz.InfiniteLevel)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.Bloxorz.InfiniteLevel,ModifiedNames(changes = UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName(InfiniteLevel,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The streams_bloxorz.Bloxorz.InfiniteLevel has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName(InfiniteLevel,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.Bloxorz.InfiniteLevel)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.GameDef.Up...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.GameDef.Up)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.GameDef.Up)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(ne,[Default]), UsedName(Up,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.GameDef.Up,ModifiedNames(changes = UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 2 classes due to The streams_bloxorz.GameDef.Up has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.GameDef.Up)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(streams_bloxorz.BloxorzSuite.SolutionChecker)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.Bloxorz.Level0...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.Bloxorz.Level0)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.Bloxorz.Level0)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.Bloxorz.Level0,ModifiedNames(changes = UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(level,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(terrainFunction,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(findChar,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(Level0,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The streams_bloxorz.Bloxorz.Level0 has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(level,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(terrainFunction,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(findChar,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(Level0,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.Bloxorz.Level0)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Var...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Var)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Var)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Var,ModifiedNames(changes = UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(computeValue,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Var;init;,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(Var,[Default]), UsedName(hashCode,[Default]), UsedName(update,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The Var has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(computeValue,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Var;init;,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(Var,[Default]), UsedName(hashCode,[Default]), UsedName(update,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Var)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.Bloxorz.Level1...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.Bloxorz.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.Bloxorz.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.Bloxorz.Level1,ModifiedNames(changes = UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(Level1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(level,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(terrainFunction,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(findChar,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The streams_bloxorz.Bloxorz.Level1 has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(pathsFromStart,[Default]), UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(solution,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(pathsToGoal,[Default]), UsedName(getClass,[Default]), UsedName(Level1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(level,[Default]), UsedName(neighborsWithHistory,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(terrainFunction,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(done,[Default]), UsedName(Pos,[Default]), UsedName(findChar,[Default]), UsedName(newNeighborsOnly,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(from,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.Bloxorz.Level1)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.InfiniteTerrain...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.InfiniteTerrain)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding streams_bloxorz.Bloxorz.InfiniteLevel by streams_bloxorz.InfiniteTerrain[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.Bloxorz.InfiniteLevel, streams_bloxorz.InfiniteTerrain)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.Bloxorz.InfiniteLevel: Set(UsedName(startPos,[Default]), UsedName(goal,[Default]), UsedName(Pos,[Default]), UsedName(InfiniteTerrain,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.InfiniteTerrain,ModifiedNames(changes = UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Pos,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(InfiniteTerrain,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 2 classes due to The streams_bloxorz.InfiniteTerrain has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Terrain,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(Move,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(startPos,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Right,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(goal,[Default]), UsedName(Block,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Pos,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(Down,[Default]), UsedName($init$,[Default]), UsedName(Up,[Default]), UsedName(terrain,[Default]), UsedName(InfiniteTerrain,[Default]), UsedName(startBlock,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.Bloxorz.InfiniteLevel, streams_bloxorz.InfiniteTerrain)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(streams_bloxorz.Bloxorz.InfiniteLevel)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Polynomial...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Polynomial)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Polynomial)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Polynomial,ModifiedNames(changes = UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(computeDelta,[Default]), UsedName(toString,[Default]), UsedName(Polynomial,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(computeSolutions,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The Polynomial has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(computeDelta,[Default]), UsedName(toString,[Default]), UsedName(Polynomial,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(computeSolutions,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Polynomial)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from BinomialHeap...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(BinomialHeap)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(BinomialHeap)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(BinomialHeap,ModifiedNames(changes = UsedName(Rank,[Default]), UsedName(insert,[Default]), UsedName(ord,[Default]), UsedName(==,[Default]), UsedName(ins,[Default]), UsedName(root,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(findMin,[Default]), UsedName(!=,[Default]), UsedName(A,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(meld,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isEmpty,[Default]), UsedName(H,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(empty,[Default]), UsedName(Node,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(rank,[Default]), UsedName(BinomialHeap,[Default]), UsedName(deleteMin,[Default]), UsedName(equals,[Default]), UsedName(link,[Default]))) invalidates 1 classes due to The BinomialHeap has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Rank,[Default]), UsedName(insert,[Default]), UsedName(ord,[Default]), UsedName(==,[Default]), UsedName(ins,[Default]), UsedName(root,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(findMin,[Default]), UsedName(!=,[Default]), UsedName(A,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(meld,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isEmpty,[Default]), UsedName(H,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(empty,[Default]), UsedName(Node,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(rank,[Default]), UsedName(BinomialHeap,[Default]), UsedName(deleteMin,[Default]), UsedName(equals,[Default]), UsedName(link,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(BinomialHeap)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from streams_bloxorz.GameDef.Left...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(streams_bloxorz.GameDef.Left)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(streams_bloxorz.GameDef.Left)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of streams_bloxorz.BloxorzSuite.SolutionChecker: Set(UsedName(==,[Default]), UsedName(ne,[Default]), UsedName(Left,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(streams_bloxorz.GameDef.Left,ModifiedNames(changes = UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]))) invalidates 2 classes due to The streams_bloxorz.GameDef.Left has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(Left,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(streams_bloxorz.GameDef.Left)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(streams_bloxorz.BloxorzSuite.SolutionChecker)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Ref...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Ref)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Ref)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Ref,ModifiedNames(changes = UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(Ref;init;,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName(Ref,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(name,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The Ref has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(productArity,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(!=,[Default]), UsedName(productPrefix,[Default]), UsedName(eq,[Default]), UsedName(Ref;init;,[Default]), UsedName(ne,[Default]), UsedName(productElement,[Default]), UsedName(isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(toString,[Default]), UsedName(Ref,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(hashCode,[Default]), UsedName(name,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Ref)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Heap...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Heap)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding IntHeap by Heap[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding BinomialHeap by Heap[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(BinomialHeap, IntHeap, Heap)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Heap,ModifiedNames(changes = UsedName(insert,[Default]), UsedName(ord,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(findMin,[Default]), UsedName(!=,[Default]), UsedName(A,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(meld,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(Heap,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isEmpty,[Default]), UsedName(H,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(empty,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(deleteMin,[Default]), UsedName(equals,[Default]))) invalidates 3 classes due to The Heap has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(insert,[Default]), UsedName(ord,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(wait,[Default]), UsedName(getClass,[Default]), UsedName(asInstanceOf,[Default]), UsedName(findMin,[Default]), UsedName(!=,[Default]), UsedName(A,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(meld,[Default]), UsedName(finalize,[Default]), UsedName($asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(Heap,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isEmpty,[Default]), UsedName(H,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(empty,[Default]), UsedName(synchronized,[Default]), UsedName(notify,[Default]), UsedName(hashCode,[Default]), UsedName(deleteMin,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(BinomialHeap, IntHeap, Heap)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mNew invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mPreviously invalidated, but (transitively) depend on new invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll newly invalidated classes after taking into account (previously) recompiled classes:Set()[0m
